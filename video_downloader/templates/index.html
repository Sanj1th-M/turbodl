<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TurboDL Video Downloader</title>
    <link rel="stylesheet" href="/static/style.css">
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600&family=Aboreto&family=Plaster&display=swap"
        rel="stylesheet">
</head>

<body>
    <canvas id="bgCanvas"></canvas>
    <div style="position: absolute; top: 20px; right: 20px; z-index: 100;">
    </div>
    <div class="container">
        <h1>turboDL</h1>
        <div class="input-group">
            <input type="text" id="urlInput" placeholder="Paste YouTube , Instagram or TikTok Video Links">
            <button id="downloadBtn" onclick="downloadVideo()">Download</button>
        </div>

        <div id="loading" class="hidden">
            <div class="spinner"></div>
            <p>Processing...</p>
        </div>

        <div id="result" class="hidden">
            <!-- Split Card Layout -->
            <div class="result-split-container">
                <!-- Left Column: Video Player (Media Stage) -->
                <div class="result-left-column">
                    <div class="video-stage">
                        <video id="videoPreview" controls class="hidden"></video>
                    </div>
                </div>

                <!-- Right Column: Controls -->
                <div class="result-right-column">
                    <h3 id="videoTitle"></h3>

                    <!-- Download Buttons Container -->
                    <div class="actions">
                        <a id="downloadLink" href="#" target="_blank" class="btn-download">Click to Save</a>
                        <a href="/" target="_blank" class="btn-secondary">Download Another</a>
                    </div>
                </div>
            </div>
        </div>

        <div id="error" class="hidden">
            <p id="errorMessage"></p>
        </div>
        <div style="margin-top: 20px; text-align: center; opacity: 0.5; font-size: 12px; color: rgb(255, 0, 0);">
        </div>
    </div>

    <script>
        /**
         * Best Quality Selector Function
         * Analyzes video formats and selects the highest quality playable format
         * 
         * Priority:
         * 1. Formats with both video AND audio (progressive MP4)
         * 2. Highest resolution (height)
         * 3. Highest bitrate
         * 
         * Filters out:
         * - Video-only DASH streams without audio
         * - Audio-only formats
         * - Non-playable formats
         */
        function selectBestQualityFormat(formats) {
            if (!formats || formats.length === 0) {
                console.warn('âš ï¸ No formats available');
                return null;
            }

            console.log('ðŸ“Š All formats received:', formats);

            // Step 1: Filter for PLAYABLE formats with audio
            // Progressive formats (type === 'video') have both video AND audio
            // Process types (type === 'process') are video-only, need merging
            const playableWithAudio = formats.filter(f => {
                // Include ONLY progressive video formats (have audio built-in)
                if (f.type === 'video') {
                    return true;
                }

                // Exclude audio-only formats
                if (f.type === 'audio') {
                    return false;
                }

                // Exclude 'process' types - they're video-only without audio
                return false;
            });

            console.log('ðŸŽµ Formats with audio (type=video):', playableWithAudio);

            // Step 2: Use formats with audio, or fallback to all video formats
            let candidateFormats = playableWithAudio.length > 0
                ? playableWithAudio
                : formats.filter(f => f.type !== 'audio');

            console.log('ðŸŽ¯ Candidate formats:', candidateFormats);

            // Step 3: Sort by quality (descending)
            // Primary: resolution (height)
            // Secondary: bitrate
            candidateFormats.sort((a, b) => {
                // Compare by height first
                const heightA = a.height || a.resolution || 0;
                const heightB = b.height || b.resolution || 0;

                if (heightB !== heightA) {
                    return heightB - heightA; // Higher resolution first
                }

                // If heights are equal, compare by bitrate
                const bitrateA = a.bitrate || a.tbr || 0;
                const bitrateB = b.bitrate || b.tbr || 0;

                return bitrateB - bitrateA; // Higher bitrate first
            });

            console.log('ðŸ“ˆ Sorted candidates:', candidateFormats);

            // Step 4: Return the best format
            const bestFormat = candidateFormats.length > 0 ? candidateFormats[0] : null;
            console.log('âœ… Selected best format:', bestFormat);

            return bestFormat;
        }

        async function downloadVideo() {
            const url = document.getElementById('urlInput').value;
            const loading = document.getElementById('loading');
            const result = document.getElementById('result');
            const error = document.getElementById('error');
            const btn = document.getElementById('downloadBtn');

            if (!url) {
                showError("Please enter a URL");
                return;
            }

            loading.classList.remove('hidden');
            result.classList.add('hidden');
            error.classList.add('hidden');
            btn.disabled = true;

            try {
                const response = await fetch('/download', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({ url: url }),
                });

                const data = await response.json();

                if (response.status === 401) {
                    window.location.href = '/login';
                    return;
                }

                if (response.ok) {
                    // Ensure title is always a string to prevent "[object] [object]" display
                    const videoTitle = String(data.title || "Video Ready");
                    document.getElementById('videoTitle').innerText = videoTitle;

                    const formats = data.formats || [];
                    // Store original URL for high-quality processing
                    const originalUrl = url;
                    const actionsDiv = document.querySelector('.actions');

                    // Remove existing download buttons (keep the reset button)
                    const existingBtns = actionsDiv.querySelectorAll('.btn-download');
                    existingBtns.forEach(btn => btn.remove());

                    // Get the reset button to insert before it
                    const resetBtn = actionsDiv.querySelector('.btn-secondary');

                    // Create a button for each format
                    // Create a button for each format
                    formats.forEach(fmt => {
                        const a = document.createElement('a');
                        a.className = 'btn-download';

                        // Insert 'a' immediately
                        actionsDiv.insertBefore(a, resetBtn);

                        // Check for High Quality (1080p, 4K, 2K, etc.)
                        let isHighQuality = false;
                        if (fmt.height && fmt.height >= 1080) {
                            isHighQuality = true;
                        }

                        // Label Logic
                        let label = `Download ${fmt.quality}`;
                        if (fmt.type === 'audio') {
                            label = `Download Audio Only`;
                        } else if (fmt.type === 'process' && isHighQuality) {
                            label = `Download ${fmt.quality} (High Quality)`;
                        }

                        if (fmt.type === 'process') {
                            a.href = "#";
                            a.innerText = label;

                            // Style Logic
                            if (isHighQuality) {
                                a.style.background = "linear-gradient(45deg, #00ff9d, #00cc7a)";
                                a.style.color = "black";
                                a.style.fontWeight = "600";
                                a.style.border = "none";
                            } else {
                                a.style.background = "white";
                                a.style.color = "black";
                                a.style.fontWeight = "600";
                                a.style.border = "1px solid #ccc";
                            }

                            a.onclick = async (e) => {
                                e.preventDefault();
                                await processAndDownload(originalUrl, a, fmt.height);
                            };

                        } else {
                            const titleStr = String(data.title || 'video');
                            const proxyUrl = `/stream_video?url=${encodeURIComponent(fmt.url)}&title=${encodeURIComponent(titleStr)}`;
                            a.href = proxyUrl;
                            a.innerText = label;
                            a.target = '_blank';
                            a.style.background = "white";
                            a.style.color = "black";
                        }
                    });

                    // Set preview to the highest quality PLAYABLE format with audio
                    if (formats.length > 0) {
                        const videoPreview = document.getElementById('videoPreview');
                        const bestFormat = selectBestQualityFormat(formats);

                        if (bestFormat) {
                            // Use stream_url if available, else url
                            const urlToStream = bestFormat.stream_url || bestFormat.url;
                            if (urlToStream) {
                                // Use the proxy to ensure playback
                                const titleStr = String(data.title || 'video');
                                videoPreview.src = `/stream_video?url=${encodeURIComponent(urlToStream)}&title=${encodeURIComponent(titleStr)}`;
                                videoPreview.classList.remove('hidden');

                                // Audio handling: 'video' type has audio, 'process' type doesn't
                                if (bestFormat.type === 'video') {
                                    videoPreview.muted = false; // Has audio
                                    console.log('ðŸ”Š Video has audio');
                                } else {
                                    videoPreview.muted = true; // Video-only (process type)
                                    console.log('ðŸ”‡ Video-only (no audio)');
                                }

                                console.log('ðŸ“º Video player source set to:', bestFormat.quality, 'format');
                            }
                        }
                    }

                    result.classList.remove('hidden');
                    btn.classList.add('hidden'); // Hide the download button upon success
                } else {
                    // Ensure error detail is converted to string
                    const errorMsg = String(data.detail || "Failed to process video");
                    showError(errorMsg);
                }
            } catch (err) {
                // Show specific JS error so we know what's wrong
                showError("Frontend Error: " + (err.message || String(err)));
                console.error(err);
            } finally {
                loading.classList.add('hidden');
                btn.disabled = false;
            }
        }

        async function processAndDownload(url, btn, quality) {
            const originalText = btn.innerText;
            btn.innerText = "Starting...";
            btn.style.opacity = "0.7";
            btn.style.pointerEvents = "none";

            try {
                // 1. Start the job
                const res = await fetch('/process_video', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ url: url, quality: quality })
                });
                const d = await res.json();

                if (res.status === 401) {
                    window.location.href = '/login';
                    return;
                }

                if (!res.ok) {
                    throw new Error(d.detail || "Failed to start processing");
                }

                const jobId = d.job_id;

                // 2. Poll for status
                const pollInterval = setInterval(async () => {
                    try {
                        const statusRes = await fetch(`/process_status/${jobId}`);
                        if (!statusRes.ok) return; // Skip this poll if error

                        const statusData = await statusRes.json();

                        if (statusData.status === 'processing') {
                            const p = Math.round(statusData.progress || 0);
                            btn.innerText = `Processing: ${p}%`;
                        } else if (statusData.status === 'completed') {
                            clearInterval(pollInterval);

                            // Download Logic
                            btn.innerText = "Download Ready - Click to Save";
                            btn.href = statusData.download_url;
                            btn.onclick = null; // Remove handler

                            // Auto trigger download
                            window.open(statusData.download_url, '_blank');

                            btn.style.pointerEvents = "auto";
                            btn.style.opacity = "1";
                            btn.style.background = "#fff";
                            btn.style.color = "#000";
                        } else if (statusData.status === 'failed') {
                            clearInterval(pollInterval);
                            throw new Error(statusData.error || "Processing failed");
                        }
                    } catch (e) {
                        // Polling error (network, etc)
                        console.error("Polling error:", e);
                    }
                }, 1000);

            } catch (e) {
                console.error(e);
                // Ensure error message is converted to string
                const errorText = e.message || String(e) || "Server error";
                alert("Error: " + errorText);
                btn.innerText = originalText;
                btn.style.opacity = "1";
                btn.style.pointerEvents = "auto";
            }
        }

        function showError(msg) {
            const errorDiv = document.getElementById('error');
            document.getElementById('errorMessage').innerText = msg;
            errorDiv.classList.remove('hidden');
        }

        function reset() {
            document.getElementById('urlInput').value = '';
            document.getElementById('result').classList.add('hidden');
            document.getElementById('error').classList.add('hidden');
            document.getElementById('videoPreview').src = '';
            document.getElementById('downloadBtn').classList.remove('hidden'); // Ensure button is visible on reset
        }

        // Add listener to show button again if user types/pastes a new URL
        document.getElementById('urlInput').addEventListener('input', () => {
            const btn = document.getElementById('downloadBtn');
            const result = document.getElementById('result');
            if (result.classList.contains('hidden') === false) {
                // If resulting video is shown, maybe hide it on input change? 
                // Or just show button? Let's just show button.
            }
            btn.classList.remove('hidden');
        });

        async function logout() {
            await fetch('/logout');
            window.location.href = '/login';
        }
    </script>
    <script src="/static/background.js"></script>
</body>

</html>