<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TurboDL Video Downloader</title>
    <link rel="stylesheet" href="/static/style.css">
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600&family=Aboreto&display=swap"
        rel="stylesheet">
</head>

<body>
    <canvas id="bgCanvas"></canvas>
    <div style="position: absolute; top: 20px; right: 20px; z-index: 100;">
    </div>
    <div class="container">
        <h1>TurboDL</h1>
        <div class="input-group">
            <input type="text" id="urlInput" placeholder="Paste YouTube or Instagram Link">
            <button id="downloadBtn" onclick="downloadVideo()">Download</button>
        </div>

        <div id="loading" class="hidden">
            <div class="spinner"></div>
            <p>Processing...</p>
        </div>

        <div id="result" class="hidden">
            <h3 id="videoTitle"></h3>
            <div class="actions">
                <a id="downloadLink" href="#" target="_blank" class="btn-download">Click to Save</a>
                <a href="/" target="_blank" class="btn-secondary">Download Another</a>
            </div>
            <video id="videoPreview" controls class="hidden"></video>
        </div>

        <div id="error" class="hidden">
            <p id="errorMessage"></p>
        </div>
        <div style="margin-top: 20px; text-align: center; opacity: 0.5; font-size: 12px; color: white;">
            v1.5 - High Quality Fixes
        </div>
    </div>

    <script>
        async function downloadVideo() {
            const url = document.getElementById('urlInput').value;
            const loading = document.getElementById('loading');
            const result = document.getElementById('result');
            const error = document.getElementById('error');
            const btn = document.getElementById('downloadBtn');

            if (!url) {
                showError("Please enter a URL");
                return;
            }

            loading.classList.remove('hidden');
            result.classList.add('hidden');
            error.classList.add('hidden');
            btn.disabled = true;

            try {
                const response = await fetch('/download', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({ url: url }),
                });

                const data = await response.json();

                if (response.status === 401) {
                    window.location.href = '/login';
                    return;
                }

                if (response.ok) {
                    // Ensure title is always a string to prevent "[object] [object]" display
                    const videoTitle = String(data.title || "Video Ready");
                    document.getElementById('videoTitle').innerText = videoTitle;

                    const formats = data.formats || [];
                    // Store original URL for high-quality processing
                    const originalUrl = url;
                    const actionsDiv = document.querySelector('.actions');

                    // Remove existing download buttons (keep the reset button)
                    const existingBtns = actionsDiv.querySelectorAll('.btn-download');
                    existingBtns.forEach(btn => btn.remove());

                    // Get the reset button to insert before it
                    const resetBtn = actionsDiv.querySelector('.btn-secondary');

                    // Create a button for each format
                    // Create a button for each format
                    formats.forEach(fmt => {
                        const a = document.createElement('a');
                        a.className = 'btn-download';

                        // Insert 'a' immediately
                        actionsDiv.insertBefore(a, resetBtn);

                        // Check for High Quality (1080p, 4K, 2K, etc.)
                        let isHighQuality = false;
                        if (fmt.height && fmt.height >= 1080) {
                            isHighQuality = true;
                        }

                        // Label Logic
                        let label = `Download ${fmt.quality}`;
                        if (fmt.type === 'audio') {
                            label = `Download Audio Only`;
                        } else if (fmt.type === 'process' && isHighQuality) {
                            label = `Download ${fmt.quality} (High Quality)`;
                        }

                        if (fmt.type === 'process') {
                            a.href = "#";
                            a.innerText = label;

                            // Style Logic
                            if (isHighQuality) {
                                a.style.background = "linear-gradient(45deg, #00ff9d, #00cc7a)";
                                a.style.color = "black";
                                a.style.fontWeight = "600";
                                a.style.border = "none";
                            } else {
                                a.style.background = "white";
                                a.style.color = "black";
                                a.style.fontWeight = "600";
                                a.style.border = "1px solid #ccc";
                            }

                            a.onclick = async (e) => {
                                e.preventDefault();
                                await processAndDownload(originalUrl, a, fmt.height);
                            };

                            // Add "Play HQ" button logic
                            if (isHighQuality) {
                                const playBtn = document.createElement('a');
                                playBtn.href = "#";
                                playBtn.innerHTML = "▶ HQ";
                                playBtn.title = "Play High Quality";
                                playBtn.className = 'btn-download';

                                playBtn.style.background = "linear-gradient(45deg, #FF512F, #DD2476)";
                                playBtn.style.color = "white";
                                playBtn.style.fontWeight = "bold";
                                playBtn.style.marginRight = "10px";
                                playBtn.style.border = "none";
                                playBtn.style.minWidth = "60px";

                                playBtn.onclick = async (e) => {
                                    e.preventDefault();
                                    await processAndDownload(originalUrl, playBtn, fmt.height, true);
                                };

                                // Insert Play button before Download button
                                // 'a' is already in DOM, so this works
                                actionsDiv.insertBefore(playBtn, a);
                            }
                        } else {
                            const titleStr = String(data.title || 'video');
                            const proxyUrl = `/stream_video?url=${encodeURIComponent(fmt.url)}&title=${encodeURIComponent(titleStr)}`;
                            a.href = proxyUrl;
                            a.innerText = label;
                            a.target = '_blank';
                            a.style.background = "white";
                            a.style.color = "black";
                        }
                    });

                    // Set preview to the highest quality PLAYABLE format (video type or process type with stream_url)
                    if (formats.length > 0) {
                        const videoPreview = document.getElementById('videoPreview');

                        // Filter playable formats:
                        // 1. type === 'video' (progressive)
                        // 2. type === 'process' AND has stream_url (video-only high quality)
                        const playable = formats
                            .filter(f => f.type === 'video' || (f.type === 'process' && f.stream_url))
                            .sort((a, b) => (b.height || 0) - (a.height || 0));

                        let previewFmt = null;

                        if (playable.length > 0) {
                            // Pick the highest resolution (1080p > 720p > ...)
                            previewFmt = playable[0];
                        } else {
                            // Fallback to anything non-audio (might be a process type without stream_url?)
                            previewFmt = formats.find(f => f.type !== 'audio' && f.type !== 'process');
                        }

                        if (previewFmt) {
                            // Use stream_url if available, else url
                            const urlToStream = previewFmt.stream_url || previewFmt.url;
                            if (urlToStream) {
                                // Use the proxy to ensure playback
                                // Ensure title is a string for URL encoding
                                const titleStr = String(data.title || 'video');
                                videoPreview.src = `/stream_video?url=${encodeURIComponent(urlToStream)}&title=${encodeURIComponent(titleStr)}`;
                                videoPreview.classList.remove('hidden');

                                // Warning if video-only high quality (process type)
                                if (previewFmt.type === 'process') {
                                    // Optional: Add a note or handle audio separately?
                                    // For now, let it play (silent high quality)
                                    videoPreview.muted = true; // Sometimes helps autoplay
                                    // Maybe show a toast "Preview is video-only for High Quality"?
                                }
                            }
                        }
                    }

                    result.classList.remove('hidden');
                    btn.classList.add('hidden'); // Hide the download button upon success
                } else {
                    // Ensure error detail is converted to string
                    const errorMsg = String(data.detail || "Failed to process video");
                    showError(errorMsg);
                }
            } catch (err) {
                // Show specific JS error so we know what's wrong
                showError("Frontend Error: " + (err.message || String(err)));
                console.error(err);
            } finally {
                loading.classList.add('hidden');
                btn.disabled = false;
            }
        }

        async function processAndDownload(url, btn, quality, isPlay = false) {
            const originalText = btn.innerText;
            btn.innerText = isPlay ? "Preparing..." : "Starting...";
            btn.style.opacity = "0.7";
            btn.style.pointerEvents = "none";

            try {
                // 1. Start the job
                const res = await fetch('/process_video', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ url: url, quality: quality })
                });
                const d = await res.json();

                if (res.status === 401) {
                    window.location.href = '/login';
                    return;
                }

                if (!res.ok) {
                    throw new Error(d.detail || "Failed to start processing");
                }

                const jobId = d.job_id;

                // 2. Poll for status
                const pollInterval = setInterval(async () => {
                    try {
                        const statusRes = await fetch(`/process_status/${jobId}`);
                        if (!statusRes.ok) return; // Skip this poll if error

                        const statusData = await statusRes.json();

                        if (statusData.status === 'processing') {
                            const p = Math.round(statusData.progress || 0);
                            btn.innerText = isPlay ? `Loading: ${p}%` : `Processing: ${p}%`;
                        } else if (statusData.status === 'completed') {
                            clearInterval(pollInterval);

                            if (isPlay) {
                                // Play Logic
                                btn.innerText = "▶ Play Again";
                                btn.onclick = async (e) => {
                                    e.preventDefault();
                                    // Simply replay existing url
                                    const videoPreview = document.getElementById('videoPreview');
                                    videoPreview.src = statusData.download_url;
                                    videoPreview.muted = false;
                                    try { await videoPreview.play(); } catch (e) { console.log(e); }
                                };

                                // Update player source and play
                                const videoPreview = document.getElementById('videoPreview');
                                videoPreview.src = statusData.download_url;
                                videoPreview.classList.remove('hidden');
                                videoPreview.muted = false; // Unmute for HQ playback
                                videoPreview.scrollIntoView({ behavior: 'smooth' });

                                try {
                                    await videoPreview.play();
                                } catch (e) {
                                    console.log("Auto-play blocked:", e);
                                }
                            } else {
                                // Download Logic
                                btn.innerText = "Download Ready - Click to Save";
                                btn.href = statusData.download_url;
                                btn.onclick = null; // Remove handler

                                // Auto trigger download
                                window.open(statusData.download_url, '_blank');
                            }

                            btn.style.pointerEvents = "auto";
                            btn.style.opacity = "1";

                            if (!isPlay) {
                                btn.style.background = "#fff";
                                btn.style.color = "#000";
                            }
                        } else if (statusData.status === 'failed') {
                            clearInterval(pollInterval);
                            throw new Error(statusData.error || "Processing failed");
                        }
                    } catch (e) {
                        // Polling error (network, etc)
                        console.error("Polling error:", e);
                    }
                }, 1000);

            } catch (e) {
                console.error(e);
                // Ensure error message is converted to string
                const errorText = e.message || String(e) || "Server error";
                alert("Error: " + errorText);
                btn.innerText = originalText;
                btn.style.opacity = "1";
                btn.style.pointerEvents = "auto";
            }
        }

        function showError(msg) {
            const errorDiv = document.getElementById('error');
            document.getElementById('errorMessage').innerText = msg;
            errorDiv.classList.remove('hidden');
        }

        function reset() {
            document.getElementById('urlInput').value = '';
            document.getElementById('result').classList.add('hidden');
            document.getElementById('error').classList.add('hidden');
            document.getElementById('videoPreview').src = '';
            document.getElementById('downloadBtn').classList.remove('hidden'); // Ensure button is visible on reset
        }

        // Add listener to show button again if user types/pastes a new URL
        document.getElementById('urlInput').addEventListener('input', () => {
            const btn = document.getElementById('downloadBtn');
            const result = document.getElementById('result');
            if (result.classList.contains('hidden') === false) {
                // If resulting video is shown, maybe hide it on input change? 
                // Or just show button? Let's just show button.
            }
            btn.classList.remove('hidden');
        });

        async function logout() {
            await fetch('/logout');
            window.location.href = '/login';
        }
    </script>
    <script src="/static/background.js"></script>
</body>

</html>